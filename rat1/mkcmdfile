#!/usr/bin/perl
#
# mkcmdfile - makes .cmd files to push via make/clogin
# 
# when ran, this produces a series of file of the 
# form machine-name_upgrade.cmd which are post
# processed by make.
#
# revision history
# .01 
#
# $clogin = "/home/plato/rat/clogin2";

use Getopt::Std;
# : after var means var takes an option, eg: h is boolean i: takes an option
# sets $opt_var as a side effect.  Eg: $opt_i = "imagename"

getopts('c:df:hlm:o:r:t:w:');
# Optional compatibility
# -c "command;command2" | -w with_cmd_from_file
# -t target | -f file_w_devices | -r routers.up -m model]
# 

if ($opt_h) {
  &help;
}

if ($opt_d) {
  print "DEBUG enabled\n";
  $debug = "true";
}

if (!$opt_o) {
# $outdir = "/home/plato/rat/mass_upgrade/";
  $outdir = "./";
} else {
  $outdir = $opt_o;
}


if ($opt_t) {
  undef @devices; # empty the device list.
  @targets = split(/,/,$opt_t);
  push @devices, @targets; # add target to device list.
} elsif ($opt_f) {
  # -f device-file containing a list of targets
  undef @devices; # empty the device list.
  dprint("device-file: $opt_f\n");
  open(DEVICES,"<$opt_f");
  while (<DEVICES>) {
    chomp($_);
    push @devices,$_; # add each device in device-file to device list.
  }
} elsif ($opt_m && $opt_r) {
  # run against models.txt
  # IP addr      device-name         device-type
  # 144.92.68.26 t-ws2102-121-1-mgmt cisco2511
  undef @devices; # empty the device list.
  open(ROUTERS,"<$opt_r");
  while (<ROUTERS>) {
    ($device,$model) = split(/:/,$_);
    if ($model =~ /$opt_m/) {
      push @devices,$device; # add matches to device list.
    }
  } # end while models.txt
} else {
  print "ERROR: missing option.\n";
  print "Must define one of:\n";
  print "   -t (target to upgrade)\n";
  print "   -f (file with a list of targets)\n";
  print "   -m (model) -r /path/to/routers.up, grep model from routers.up\n"; 
  &help;
} # end of choose one of -t target | -f file-with-devices | -m model [-e]

dprint("Devices:\n@devices\n");

# finally finished with option processing.
$start = time;

$numdev = $#devices + 1;
# dprint is a function which only prints if $debug exists.
dprint("Found $numdev target devices.\n");
if ($opt_l) {print "Found $numdev target devices.\n"; }

# limit number of files to create if -l
$limit = 4;
$limit_loop = 0;

if ($opt_c) {
  $command = $opt_c;
} elsif ($opt_w) {
  if (!(-e "$opt_w")) {
    print "Image: $opt_w does not exist.\n\n";
    &help;
  } elsif (!(-r "$opt_w")) {
    print "Image: $opt_w not readable.\n\n";
    &help;
  } else {
    dprint("Image: $opt_w exists and is readable.\n");
    # really need to stat the file to ensure it's readable
    # by the tftp server, not just this process.
  }
} else {
  $command = "show clock; show version";
}

foreach $device (@devices) {

  # don't run it on more than four devices while using -l.
  $limit_loop++;
  if (($opt_l) && ($limit_loop > $limit)) {
    exit;
  }
  
  open(CMDFILE,"> $outdir/$device.cmd") ||
    die "Cannot open $outdir/$device.cmd for output.\n";
  if ($opt_w) {
    open(CMDLIST,"< $opt_w") ||
    die "Cannot open $opt_w for input.\n";
    while (<CMDLIST>) {
      print CMDFILE;
    }
  } else {
    print CMDFILE "$command\n";
  }
  close CMDFILE;
  dprint("DEBUG: $device $command :\n");
} # end foreach device in device list

$fin = time;
$total = $fin - $start;
dprint("Exiting after $total seconds.\n");
exit;

sub dprint() {
  if ($debug) {
    print "@_";
  }
}

sub help() {

# getopts('c:df:hlm:o:w:');
# getopts('c:df:hlm:o:r:t:w:');
# c = optional command to print to CMDFILE
# d = debug
# f = device-file w list of devices
# h = help
# l = limit number of files created
# m = model from field 2 of routers.up
# o = output directory to place .cmd files in
# t = target devices: -t "dev1, dev2, dev3"
# w = with these commands (ie: -w commandfile)

  print "Usage:\n";
  print "  $0 [-d] [-h] {[-f <targetfile>] | [-t <target>] | \n";
  print "     [-m model -r routers.up] } | \n";
  print "       -c \"command list\" | -w with-command-file.txt>\n";
  print "    -d enables debugging output.\n";
  print "    -h gives this help and exits.\n";
  print "    -f <targetfile> runs against a series of targets\n";
  print "       one per line in file.\n";
  print "     Eg:\n";
  print "       machine1-fes\n";
  print "       machine2-fes\n";
  print "       machine2-fes\n";
  print "\n";
  print "    -t <target> runs against a single target or list.\n";
  print "    -m <model> runs against second field of routers.up\n";
  print "    commond models: cisco, cat5, juniper, foundry\n";
  print "    -r <routers.up> required with -m, specifies the router file.\n";
  print "    -o output directory specifies where to place the .cmd files.\n";
  print "       the default is /home/plato/rat/\n";
  print "\n";
  print "    -c \"command1; command2; command3\"\n";
  print "    -w command-file\n";
  print "       a command-file contains commands, one per line, eg:\n";
  print "           conf t\n";
  print "           vlan 391\n";
  print "             name my_vlan\n";
  print "             exit\n";
  print "             wr mem\n";
  print "\n";
  exit;
}
